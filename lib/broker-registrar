#!/usr/bin/env ruby

require 'optparse'
require 'cfoundry'
require 'httparty'

def usage
  'Usage: --cf-address <URL> --cf-username <CF username> --cf-password <CF password> --broker-name <broker name> --broker-url <broker URL> --broker-username <broker username> --broker-password <broker password>'
end

def parse_arguments
  options = {}
  option_parser = OptionParser.new do |opts|
    opts.banner = usage

    opts.on('--cf-address URL', 'Cloud Foundry URL') do |cf_address|
      options[:cf_address] = cf_address
    end
    opts.on('--cf-username USERNAME', 'Cloud Foundry username') do |cf_username|
      options[:cf_username] = cf_username
    end
    opts.on('--cf-password PASSWORD', 'Cloud Foundry password') do |cf_password|
      options[:cf_password] = cf_password
    end
    opts.on('--broker-name BROKER_NAME', 'Broker name') do |broker_name|
      options[:broker_name] = broker_name
    end
    opts.on('--broker-url BROKER_URL', 'Broker URL') do |broker_url|
      options[:broker_url] = broker_url
    end
    opts.on('--broker-username BROKER_USERNAME', 'Broker username') do |broker_username|
      options[:broker_username] = broker_username
    end
    opts.on('--broker-password BROKER_PASSWORD', 'Broker password') do |broker_password|
      options[:broker_password] = broker_password
    end
  end

  option_parser.parse!

  raise OptionParser::MissingArgument.new('cf-address') if options[:cf_address].nil?
  raise OptionParser::MissingArgument.new('cf-username') if options[:cf_username].nil?
  raise OptionParser::MissingArgument.new('cf-password') if options[:cf_password].nil?
  raise OptionParser::MissingArgument.new('broker-name') if options[:broker_name].nil?
  raise OptionParser::MissingArgument.new('broker-url') if options[:broker_url].nil?
  raise OptionParser::MissingArgument.new('broker-username') if options[:broker_username].nil?
  raise OptionParser::MissingArgument.new('broker-password') if options[:broker_password].nil?

  options
end

def find_or_create_service_broker!(args, client)
  broker               = client.service_broker
  broker.name          = args[:broker_name]
  broker.broker_url    = args[:broker_url]
  broker.auth_username = args[:broker_username]
  broker.auth_password = args[:broker_password]
  puts "Adding service broker #{broker.name}"

  begin
    broker.create!
  rescue CFoundry::APIError => e
    if e.error_code == 270003
      broker = client.service_broker_by_name(args[:broker_name])
    else
      raise e
    end
  end

  broker
end

def get_services_for_broker(client, broker_url, broker_username, broker_password)
  credentials = { username: broker_username, password: broker_password }
  response = HTTParty.get("#{broker_url}/v2/catalog", basic_auth: credentials)
  broker_provided_ids = extract_broker_provided_ids(response)
  client.services.find_all { |s| broker_provided_ids.include?(s.unique_id) }
end

def extract_broker_provided_ids(response)
  response['services'].map { |s| s['id'] }
end

def make_services_plans_public(services)
  services.each do |service|
    service.service_plans.each { |sp| make_service_plan_public(sp) }
  end
end

def make_service_plan_public(service_plan)
  puts "Making service plan #{service_plan.name} public"
  service_plan.public = true
  service_plan.update!
end

begin
  args = parse_arguments

  client = CFoundry::V2::Client.new(args[:cf_address])
  client.login(username: args[:cf_username], password: args[:cf_password])

  broker   = find_or_create_service_broker!(args, client)
  services = get_services_for_broker(client, broker.broker_url, args[:broker_username], args[:broker_password])
  puts 'Found services for new broker: ' + services.map(&:label).join(', ')
  make_services_plans_public(services)

rescue => e
  puts usage
  puts e.message
  puts e.backtrace

  exit 2
end

exit 0
